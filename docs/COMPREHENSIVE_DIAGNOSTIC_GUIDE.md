# Multi-Agent Observability System - Comprehensive Diagnostic Guide

## Overview

This guide provides comprehensive diagnostic and troubleshooting procedures for the Multi-Agent Observability System when dashboard tabs appear empty or show "No events yet", "No Applications Detected", "No Agent Activity".

## Issue Context

**Problem**: Dashboard tabs (Timeline, Applications, Agents, Classic) appear empty despite the system appearing to run normally.

**Root Causes**:
- Hook events not being generated by Claude Code operations
- API endpoints returning empty data due to database issues
- WebSocket connection failures preventing real-time updates
- Session correlation issues preventing proper event tracking
- Hook installation or configuration problems

## 1. IMMEDIATE DIAGNOSTIC CHECKLIST (5 minutes)

### ✅ Quick System Health Check

```bash
# 1. Verify services are running
ps aux | grep -E "(node|bun)" | grep -v grep
# Expected: Should show server processes running

# 2. Check database exists and has data
ls -la /home/bryan/multi-agent-observability-system/*.db
sqlite3 /home/bryan/multi-agent-observability-system/database.db "SELECT COUNT(*) FROM events;"
# Expected: Database file exists, event count > 0

# 3. Test API endpoints
curl -s "http://localhost:3456/api/hook-coverage" | jq '.hooks | length'
# Expected: Should return number > 0

# 4. Check Redis connection
redis-cli ping
# Expected: PONG

# 5. Verify hooks are installed
ls -la .claude/hooks/
cat .claude/settings.local.json | jq '.hooks'
# Expected: Hook files exist, settings configured
```

### 🚨 Critical Path Verification

```bash
# Test the complete data pipeline
echo "=== Testing Complete Data Pipeline ==="

# 1. Check recent events in database
sqlite3 database.db "SELECT COUNT(*), hook_event_type FROM events WHERE timestamp > $(date -d '1 day ago' +%s)000 GROUP BY hook_event_type;"

# 2. Test API data flow
curl -s "http://localhost:3456/api/hook-coverage" | jq '.totalActiveHooks, .totalInactiveHooks'

# 3. Check session files exist
ls -la /tmp/claude_session_*

# 4. Verify WebSocket server
curl -I "http://localhost:3456" | grep "websocket\|upgrade"
```

## 2. SYSTEM VERIFICATION PROCEDURES

### Database Deep Dive

```bash
# Database integrity and content check
echo "=== Database Analysis ==="

# Check database structure
sqlite3 database.db ".schema events"

# Check data distribution by hook type
sqlite3 database.db "
SELECT
  hook_event_type,
  COUNT(*) as total,
  COUNT(DISTINCT session_id) as unique_sessions,
  MIN(timestamp) as earliest,
  MAX(timestamp) as latest
FROM events
GROUP BY hook_event_type
ORDER BY total DESC;
"

# Check for naming convention issues
sqlite3 database.db "
SELECT DISTINCT hook_event_type
FROM events
WHERE hook_event_type LIKE '%Start%' OR hook_event_type LIKE '%start%';
"

# Verify session correlation
sqlite3 database.db "
SELECT COUNT(*) as events_with_session_id
FROM events
WHERE session_id IS NOT NULL AND session_id != 'unknown';
"
```

### API Endpoint Validation

```bash
# Test all critical API endpoints
echo "=== API Endpoint Testing ==="

# 1. Hook Coverage (main dashboard data)
echo "Testing hook coverage..."
curl -s "http://localhost:3456/api/hook-coverage" | jq '.'

# 2. Test specific hook endpoints
for hook in session_start pre_tool_use post_tool_use subagent_start subagent_stop; do
  echo "Testing $hook endpoint..."
  curl -s "http://localhost:3456/api/hooks/$hook/enhanced-context" | jq '.totalExecutions'
  curl -s "http://localhost:3456/api/hooks/$hook/performance" | jq '.totalExecutions'
  curl -s "http://localhost:3456/api/hooks/$hook/recent-events?limit=1" | jq 'length'
done

# 3. Test error conditions
curl -s "http://localhost:3456/api/hooks/nonexistent/enhanced-context" | jq '.'
```

### WebSocket Connection Testing

```bash
# WebSocket connectivity verification
echo "=== WebSocket Testing ==="

# Test WebSocket connection (requires wscat: npm install -g wscat)
if command -v wscat &> /dev/null; then
  echo "Testing WebSocket connection..."
  timeout 5s wscat -c ws://localhost:3456 -x '{"type":"ping"}' || echo "WebSocket test failed"
else
  echo "Install wscat: npm install -g wscat"
fi

# Alternative WebSocket test with curl
curl -i -N -H "Connection: Upgrade" \
     -H "Upgrade: websocket" \
     -H "Sec-WebSocket-Version: 13" \
     -H "Sec-WebSocket-Key: SGVsbG8sIHdvcmxkIQ==" \
     http://localhost:3456/
```

## 3. EVENT GENERATION TESTING

### Manual Hook Event Generation

```bash
# Generate test events to verify system is working
echo "=== Generating Test Events ==="

# 1. Create a test session file
test_session="test_$(date +%s)"
echo -e "${test_session}\n$(date -Iseconds)" > /tmp/claude_session_multi-agent-observability-system
chmod 600 /tmp/claude_session_multi-agent-observability-system

# 2. Simulate hook events by running hook scripts directly
cd .claude/hooks/

# Test SessionStart hook
python3 session_start.py <<< '{"session_id": "'${test_session}'", "timestamp": '$(date +%s)'000}'

# Test tool usage hooks
python3 pre_tool_use.py <<< '{"tool": "Read", "tool_input": {"file_path": "/test"}, "timestamp": '$(date +%s)'000}'
python3 post_tool_use.py <<< '{"tool": "Read", "tool_result": "test output", "timestamp": '$(date +%s)'000}'

# 3. Verify events were created
sqlite3 ../database.db "SELECT * FROM events WHERE session_id = '${test_session}' ORDER BY timestamp DESC;"
```

### Database Population Script

```sql
-- Create sample events for testing (save as test_events.sql)
INSERT INTO events (
  session_id, hook_event_type, source_app, timestamp, payload
) VALUES
  ('test_session_001', 'SessionStart', 'multi-agent-observability-system', 1703789234567, '{"user": "test"}'),
  ('test_session_001', 'PreToolUse', 'multi-agent-observability-system', 1703789234568, '{"tool": "Read", "file_path": "/test.txt"}'),
  ('test_session_001', 'PostToolUse', 'multi-agent-observability-system', 1703789234569, '{"tool": "Read", "result": "success"}'),
  ('test_session_002', 'SubagentStart', 'multi-agent-observability-system', 1703789234570, '{"agent_type": "analyzer"}'),
  ('test_session_002', 'SubagentStop', 'multi-agent-observability-system', 1703789234571, '{"agent_type": "analyzer", "duration": 1234}');

-- Run with: sqlite3 database.db < test_events.sql
```

### End-to-End Workflow Simulation

```bash
# Simulate complete Claude Code session
echo "=== E2E Workflow Simulation ==="

# 1. Start a new session
echo "Starting Claude Code session simulation..."
session_id="sim_$(date +%s)"

# 2. Create session file
echo -e "${session_id}\n$(date -Iseconds)" > /tmp/claude_session_multi-agent-observability-system

# 3. Simulate typical workflow
cd .claude/hooks/

# Session start
python3 session_event_tracker.py <<< "{\"session_id\": \"${session_id}\", \"event_type\": \"start\"}"

# Tool usage sequence
sleep 1
python3 pre_tool_use.py <<< "{\"tool\": \"Read\", \"tool_input\": {\"file_path\": \"README.md\"}}"
sleep 1
python3 post_tool_use.py <<< "{\"tool\": \"Read\", \"tool_result\": \"File content...\"}"

# Sub-agent activity
sleep 1
python3 subagent_start.py <<< "{\"agent_name\": \"TestAnalyzer\", \"description\": \"Test analysis agent\"}"
sleep 2
python3 subagent_stop.py <<< "{\"agent_name\": \"TestAnalyzer\", \"result\": \"Analysis complete\"}"

# 4. Verify events were generated
echo "Checking generated events..."
sqlite3 ../database.db "SELECT hook_event_type, timestamp FROM events WHERE session_id = '${session_id}' ORDER BY timestamp;"

# 5. Test API response
echo "Testing API response..."
curl -s "http://localhost:3456/api/hook-coverage" | jq '.hooks[] | select(.executionCount > 0) | {type: .type, count: .executionCount}'
```

## 4. TROUBLESHOOTING DECISION TREE

### If Database Has No Events

```bash
# Problem: sqlite3 database.db "SELECT COUNT(*) FROM events;" returns 0

# Solution Path A: Check hook installation
echo "=== Checking Hook Installation ==="
ls -la .claude/hooks/*.py
cat .claude/settings.local.json | jq '.hooks'

# If hooks not installed:
./bin/install-hooks.sh

# Solution Path B: Check hook execution
echo "=== Testing Hook Execution ==="
cd .claude/hooks/
export HOOK_DEBUG=true
python3 session_start.py --test

# If hooks fail to execute:
# Check dependencies
python3 -c "import requests, sqlite3, redis; print('Dependencies OK')"

# Install missing dependencies
pip install requests redis
```

### If API Returns Empty Data

```bash
# Problem: curl "http://localhost:3456/api/hook-coverage" returns empty hooks array

# Solution Path A: Check API server
echo "=== Checking API Server ==="
curl -s "http://localhost:3456/health" | jq '.'

# If server not responding:
cd apps/server && npm run dev

# Solution Path B: Check database connection
echo "=== Testing Database Connection ==="
node -e "
const Database = require('better-sqlite3');
try {
  const db = new Database('./database.db');
  console.log('Events:', db.prepare('SELECT COUNT(*) as count FROM events').get());
  db.close();
} catch (err) {
  console.error('Database error:', err.message);
}
"
```

### If WebSocket Not Working

```bash
# Problem: Real-time updates not working, WebSocket errors in browser console

# Solution Path A: Check WebSocket server
echo "=== Checking WebSocket Server ==="
netstat -tulpn | grep :3456

# If port not listening:
# Check server configuration in apps/server/src/index.ts
grep -n "WebSocket\|websocket" apps/server/src/index.ts

# Solution Path B: Test WebSocket manually
if command -v websocat &> /dev/null; then
  echo "Testing WebSocket..."
  echo '{"type":"ping"}' | websocat ws://localhost:3456
else
  echo "Install websocat for WebSocket testing: cargo install websocat"
fi
```

## 5. CONFIGURATION VERIFICATION

### Hook System Configuration

```bash
# Complete hook system verification
echo "=== Hook Configuration Verification ==="

# 1. Check Claude settings
echo "Claude settings:"
cat .claude/settings.local.json | jq '.hooks // "No hooks configured"'

# 2. Verify hook file permissions and syntax
echo "Hook file verification:"
for hook in .claude/hooks/*.py; do
  echo "Checking $hook..."
  python3 -m py_compile "$hook" && echo "✅ Syntax OK" || echo "❌ Syntax error"
  ls -la "$hook" | grep -q "^-r.xr.xr.x" && echo "✅ Executable" || echo "❌ Not executable"
done

# 3. Test environment variables and paths
echo "Environment check:"
python3 -c "
import sys, os
print('Python path:', sys.executable)
print('Working dir:', os.getcwd())
print('Claude hooks path:', os.path.exists('.claude/hooks'))
"

# 4. Check dependencies
echo "Dependency check:"
python3 -c "
try:
    import requests, redis, sqlite3
    print('✅ All dependencies available')
except ImportError as e:
    print('❌ Missing dependency:', e)
"
```

### Project Structure Validation

```bash
# Verify project structure
echo "=== Project Structure Validation ==="

# Check required files exist
required_files=(
  ".claude/settings.local.json"
  ".claude/hooks/session_start.py"
  ".claude/hooks/pre_tool_use.py"
  ".claude/hooks/post_tool_use.py"
  ".claude/hooks/subagent_start.py"
  ".claude/hooks/subagent_stop.py"
  "apps/server/package.json"
  "apps/client/package.json"
)

for file in "${required_files[@]}"; do
  [[ -f "$file" ]] && echo "✅ $file" || echo "❌ Missing: $file"
done

# Check directory structure
required_dirs=(
  "apps/server/src"
  "apps/client/src"
  ".claude/hooks/utils"
  "docs"
)

for dir in "${required_dirs[@]}"; do
  [[ -d "$dir" ]] && echo "✅ $dir/" || echo "❌ Missing: $dir/"
done
```

## 6. USER EXPERIENCE IMPROVEMENTS

### Better Empty State Implementation

```javascript
// Enhanced empty state component (apps/client/src/components/EmptyState.vue)
<template>
  <div class="empty-state">
    <div class="empty-state-content">
      <div class="empty-state-icon">{{ icon }}</div>
      <h3 class="empty-state-title">{{ title }}</h3>
      <p class="empty-state-description">{{ description }}</p>

      <!-- Diagnostic information -->
      <details class="diagnostic-info" v-if="showDiagnostics">
        <summary>System Diagnostics</summary>
        <div class="diagnostic-details">
          <p><strong>Database Events:</strong> {{ diagnostics.eventCount }}</p>
          <p><strong>API Status:</strong> {{ diagnostics.apiStatus }}</p>
          <p><strong>Last Update:</strong> {{ diagnostics.lastUpdate }}</p>
          <p><strong>Hooks Installed:</strong> {{ diagnostics.hooksInstalled ? '✅' : '❌' }}</p>
        </div>
      </details>

      <!-- Action buttons -->
      <div class="empty-state-actions">
        <button @click="runDiagnostics" class="btn-primary">
          Run Diagnostics
        </button>
        <button @click="generateSampleData" class="btn-secondary">
          Generate Sample Data
        </button>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  name: 'EmptyState',
  props: {
    type: String, // 'timeline', 'applications', 'agents', 'classic'
    icon: String,
    title: String,
    description: String
  },
  data() {
    return {
      showDiagnostics: false,
      diagnostics: {
        eventCount: 0,
        apiStatus: 'unknown',
        lastUpdate: null,
        hooksInstalled: false
      }
    }
  },
  methods: {
    async runDiagnostics() {
      this.showDiagnostics = true;

      try {
        // Check API status
        const response = await fetch('/api/hook-coverage');
        this.diagnostics.apiStatus = response.ok ? 'connected' : 'error';

        if (response.ok) {
          const data = await response.json();
          this.diagnostics.eventCount = data.hooks?.reduce((sum, h) => sum + h.executionCount, 0) || 0;
          this.diagnostics.lastUpdate = new Date().toLocaleString();
        }

        // Check hooks installation (would need backend endpoint)
        const hooksResponse = await fetch('/api/system/hooks-status');
        if (hooksResponse.ok) {
          const hooksData = await hooksResponse.json();
          this.diagnostics.hooksInstalled = hooksData.installed;
        }

      } catch (error) {
        this.diagnostics.apiStatus = 'error: ' + error.message;
      }
    },

    async generateSampleData() {
      try {
        await fetch('/api/system/generate-sample-data', { method: 'POST' });
        this.$emit('refresh-data');
      } catch (error) {
        console.error('Failed to generate sample data:', error);
      }
    }
  }
}
</script>
```

### Loading States and Error Handling

```javascript
// Enhanced loading and error states
// apps/client/src/components/Dashboard.vue (partial)

<template>
  <div class="dashboard">
    <!-- Loading overlay -->
    <div v-if="isLoading" class="loading-overlay">
      <div class="loading-spinner"></div>
      <p>Loading observability data...</p>
    </div>

    <!-- Error state -->
    <div v-else-if="error" class="error-state">
      <div class="error-icon">⚠️</div>
      <h3>Unable to Load Data</h3>
      <p>{{ error }}</p>
      <div class="error-actions">
        <button @click="retryLoad" class="btn-primary">Retry</button>
        <button @click="showTroubleshooting = true" class="btn-secondary">
          Troubleshooting Guide
        </button>
      </div>
    </div>

    <!-- Troubleshooting modal -->
    <TroubleshootingModal
      v-if="showTroubleshooting"
      @close="showTroubleshooting = false"
    />
  </div>
</template>

<script>
export default {
  data() {
    return {
      isLoading: true,
      error: null,
      showTroubleshooting: false,
      retryCount: 0
    }
  },
  methods: {
    async loadData() {
      this.isLoading = true;
      this.error = null;

      try {
        // Load data with timeout
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 10000);

        const response = await fetch('/api/hook-coverage', {
          signal: controller.signal
        });

        clearTimeout(timeout);

        if (!response.ok) {
          throw new Error(`API Error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        // Process data...

      } catch (error) {
        if (error.name === 'AbortError') {
          this.error = 'Request timed out. Check system status.';
        } else {
          this.error = error.message;
        }
      } finally {
        this.isLoading = false;
      }
    },

    async retryLoad() {
      this.retryCount++;
      if (this.retryCount > 3) {
        this.error = 'Maximum retry attempts reached. Please check system status.';
        return;
      }

      await this.loadData();
    }
  }
}
</script>
```

## 7. QUICK FIXES FOR COMMON ISSUES

### Fix: No Events Generated

```bash
# Quick fix for missing events
echo "=== Quick Event Generation Fix ==="

# 1. Generate immediate test event
curl -X POST "http://localhost:3456/api/events" \
  -H "Content-Type: application/json" \
  -d '{
    "hook_event_type": "SessionStart",
    "session_id": "quickfix_test",
    "source_app": "multi-agent-observability-system",
    "timestamp": '$(date +%s)'000',
    "payload": {"test": true}
  }'

# 2. Refresh browser and check Timeline tab
echo "Check Timeline tab in browser - should show new event"
```

### Fix: API Endpoints Return 404

```bash
# Quick fix for API routing issues
echo "=== API Route Fix ==="

# 1. Restart server with debug logs
cd apps/server
DEBUG=* npm run dev

# 2. Test endpoints systematically
curl -v "http://localhost:3456/api/hook-coverage"
curl -v "http://localhost:3456/api/hooks/session_start/enhanced-context"
```

### Fix: WebSocket Connection Issues

```javascript
// Quick WebSocket reconnection fix
// Add to apps/client/src/utils/websocket.js

class RobustWebSocket {
  constructor(url) {
    this.url = url;
    this.reconnectDelay = 1000;
    this.maxReconnectDelay = 30000;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 10;
    this.connect();
  }

  connect() {
    console.log('Connecting to WebSocket:', this.url);

    this.ws = new WebSocket(this.url);

    this.ws.onopen = () => {
      console.log('WebSocket connected');
      this.reconnectAttempts = 0;
      this.reconnectDelay = 1000;
    };

    this.ws.onclose = () => {
      console.log('WebSocket disconnected');
      this.scheduleReconnect();
    };

    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };

    this.ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        this.handleMessage(data);
      } catch (error) {
        console.error('Failed to parse WebSocket message:', error);
      }
    };
  }

  scheduleReconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnection attempts reached');
      return;
    }

    this.reconnectAttempts++;

    setTimeout(() => {
      this.connect();
    }, this.reconnectDelay);

    this.reconnectDelay = Math.min(this.reconnectDelay * 2, this.maxReconnectDelay);
  }

  handleMessage(data) {
    // Emit events for components to listen to
    window.dispatchEvent(new CustomEvent('websocket-message', { detail: data }));
  }
}

// Usage:
// const ws = new RobustWebSocket('ws://localhost:3456');
```

## 8. PERFORMANCE OPTIMIZATION

### Response Time Monitoring

```bash
# Monitor API response times
echo "=== Performance Monitoring ==="

# Create response time test
curl -w "
Response Time Breakdown:
- DNS Resolution: %{time_namelookup}s
- Connection: %{time_connect}s
- Transfer: %{time_starttransfer}s
- Total: %{time_total}s
Response Size: %{size_download} bytes
" -o /dev/null -s "http://localhost:3456/api/hook-coverage"

# Test all critical endpoints
endpoints=(
  "hook-coverage"
  "hooks/session_start/enhanced-context"
  "hooks/pre_tool_use/performance"
  "hooks/subagent_start/recent-events"
)

for endpoint in "${endpoints[@]}"; do
  echo "Testing /$endpoint..."
  time curl -s "http://localhost:3456/api/$endpoint" > /dev/null
done
```

### Database Optimization

```sql
-- Database performance optimization
-- Run these in sqlite3 database.db

-- Add indexes for faster queries
CREATE INDEX IF NOT EXISTS idx_events_hook_type ON events(hook_event_type);
CREATE INDEX IF NOT EXISTS idx_events_timestamp ON events(timestamp);
CREATE INDEX IF NOT EXISTS idx_events_session_id ON events(session_id);
CREATE INDEX IF NOT EXISTS idx_events_source_app ON events(source_app);

-- Analyze query performance
EXPLAIN QUERY PLAN
SELECT * FROM events
WHERE hook_event_type = 'SessionStart'
AND timestamp > 1703700000000
ORDER BY timestamp DESC
LIMIT 50;

-- Check database statistics
SELECT
  COUNT(*) as total_events,
  COUNT(DISTINCT session_id) as unique_sessions,
  COUNT(DISTINCT hook_event_type) as event_types,
  MIN(timestamp) as earliest_event,
  MAX(timestamp) as latest_event
FROM events;
```

## 9. MONITORING AND ALERTS

### Health Check Script

```bash
#!/bin/bash
# Save as bin/health-check.sh

echo "=== Multi-Agent Observability System Health Check ==="
echo "Timestamp: $(date)"

# Service checks
echo "Services:"
if pgrep -f "apps/server" > /dev/null; then
  echo "✅ Server running"
else
  echo "❌ Server not running"
fi

if pgrep -f "apps/client" > /dev/null; then
  echo "✅ Client running"
else
  echo "❌ Client not running"
fi

# Database check
echo "Database:"
if [[ -f "database.db" ]]; then
  event_count=$(sqlite3 database.db "SELECT COUNT(*) FROM events;" 2>/dev/null || echo "0")
  echo "✅ Database exists ($event_count events)"
else
  echo "❌ Database missing"
fi

# Redis check
echo "Redis:"
if redis-cli ping >/dev/null 2>&1; then
  echo "✅ Redis connected"
else
  echo "❌ Redis not accessible"
fi

# API check
echo "API:"
if curl -s "http://localhost:3456/api/hook-coverage" >/dev/null 2>&1; then
  echo "✅ API responding"
else
  echo "❌ API not responding"
fi

# Hook files check
echo "Hooks:"
hook_count=$(ls .claude/hooks/*.py 2>/dev/null | wc -l)
if [[ $hook_count -gt 0 ]]; then
  echo "✅ $hook_count hook files found"
else
  echo "❌ No hook files found"
fi

echo "=== Health Check Complete ==="
```

### Automated Monitoring Setup

```bash
# Set up automated monitoring (add to crontab)
# crontab -e

# Check system health every 5 minutes
*/5 * * * * /home/bryan/multi-agent-observability-system/bin/health-check.sh >> /var/log/mas-health.log 2>&1

# Generate sample events if no activity for 1 hour
0 * * * * /home/bryan/multi-agent-observability-system/bin/generate-heartbeat-events.sh
```

## Summary

This comprehensive guide provides systematic procedures to diagnose and resolve empty dashboard issues in the Multi-Agent Observability System. Follow the diagnostic checklist first, then use the specific troubleshooting procedures based on your findings.

Key areas to focus on:
1. **Hook Installation**: Ensure hooks are properly installed and configured
2. **Database Population**: Verify events are being written to the database
3. **API Functionality**: Test all API endpoints return data
4. **WebSocket Connectivity**: Ensure real-time updates are working
5. **System Integration**: Verify all services are running and communicating

For immediate results, use the Quick Fixes section and the Event Generation Testing procedures to populate the system with sample data.